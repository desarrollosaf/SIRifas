import { Directive, Input, forwardRef, } from '@angular/core';
import { NG_VALIDATORS, } from '@angular/forms';
import { rangeLength } from './validator';
import * as i0 from "@angular/core";
const RANGE_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => RangeLengthValidator),
    multi: true,
};
export class RangeLengthValidator {
    rangeLength;
    validator;
    onChange;
    ngOnInit() {
        this.validator = rangeLength(this.rangeLength);
    }
    ngOnChanges(changes) {
        for (const key in changes) {
            if (key === 'rangeLength') {
                this.validator = rangeLength(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: RangeLengthValidator, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.2", type: RangeLengthValidator, selector: "[rangeLength][formControlName],[rangeLength][formControl],[rangeLength][ngModel]", inputs: { rangeLength: "rangeLength" }, providers: [RANGE_LENGTH_VALIDATOR], usesOnChanges: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: RangeLengthValidator, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rangeLength][formControlName],[rangeLength][formControl],[rangeLength][ngModel]',
                    providers: [RANGE_LENGTH_VALIDATOR],
                }]
        }], propDecorators: { rangeLength: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmFyaWstY3VzdG9tLXZhbGlkYXRvcnMvc3JjL2xpYi9yYW5nZS1sZW5ndGgvZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsS0FBSyxFQUNMLFVBQVUsR0FJYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQ0gsYUFBYSxHQUloQixNQUFNLGdCQUFnQixDQUFDO0FBRXhCLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxhQUFhLENBQUM7O0FBRTFDLE1BQU0sc0JBQXNCLEdBQVE7SUFDaEMsT0FBTyxFQUFFLGFBQWE7SUFDdEIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQztJQUNuRCxLQUFLLEVBQUUsSUFBSTtDQUNkLENBQUM7QUFPRixNQUFNLE9BQU8sb0JBQW9CO0lBQ3BCLFdBQVcsQ0FBbUI7SUFFL0IsU0FBUyxDQUFjO0lBQ3ZCLFFBQVEsQ0FBYTtJQUU3QixRQUFRO1FBQ0osSUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDOUIsS0FBSyxNQUFNLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztZQUN4QixJQUFJLEdBQUcsS0FBSyxhQUFhLEVBQUUsQ0FBQztnQkFDeEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUN4RCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDaEIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNwQixDQUFDO1lBQ0wsQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0lBRUQsUUFBUSxDQUFDLENBQWtCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQseUJBQXlCLENBQUMsRUFBYztRQUNwQyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUN2QixDQUFDO3VHQTNCUSxvQkFBb0I7MkZBQXBCLG9CQUFvQixtSkFGbEIsQ0FBQyxzQkFBc0IsQ0FBQzs7MkZBRTFCLG9CQUFvQjtrQkFMaEMsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQ0osa0ZBQWtGO29CQUN0RixTQUFTLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQztpQkFDdEM7OEJBRVksV0FBVztzQkFBbkIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgICBEaXJlY3RpdmUsXHJcbiAgICBJbnB1dCxcclxuICAgIGZvcndhcmRSZWYsXHJcbiAgICBPbkluaXQsXHJcbiAgICBPbkNoYW5nZXMsXHJcbiAgICBTaW1wbGVDaGFuZ2VzLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gICAgTkdfVkFMSURBVE9SUyxcclxuICAgIFZhbGlkYXRvcixcclxuICAgIFZhbGlkYXRvckZuLFxyXG4gICAgQWJzdHJhY3RDb250cm9sLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuXHJcbmltcG9ydCB7IHJhbmdlTGVuZ3RoIH0gZnJvbSAnLi92YWxpZGF0b3InO1xyXG5cclxuY29uc3QgUkFOR0VfTEVOR1RIX1ZBTElEQVRPUjogYW55ID0ge1xyXG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcclxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhbmdlTGVuZ3RoVmFsaWRhdG9yKSxcclxuICAgIG11bHRpOiB0cnVlLFxyXG59O1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjpcclxuICAgICAgICAnW3JhbmdlTGVuZ3RoXVtmb3JtQ29udHJvbE5hbWVdLFtyYW5nZUxlbmd0aF1bZm9ybUNvbnRyb2xdLFtyYW5nZUxlbmd0aF1bbmdNb2RlbF0nLFxyXG4gICAgcHJvdmlkZXJzOiBbUkFOR0VfTEVOR1RIX1ZBTElEQVRPUl0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBSYW5nZUxlbmd0aFZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25Jbml0LCBPbkNoYW5nZXMge1xyXG4gICAgQElucHV0KCkgcmFuZ2VMZW5ndGg6IFtudW1iZXIsIG51bWJlcl07XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xyXG4gICAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IHJhbmdlTGVuZ3RoKHRoaXMucmFuZ2VMZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdyYW5nZUxlbmd0aCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gcmFuZ2VMZW5ndGgoY2hhbmdlc1trZXldLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcclxuICAgIH1cclxufVxyXG4iXX0=