import { ChangeDetectionStrategy, Component, EventEmitter, HostListener, inject, Input, Output, ViewChild } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { DatatableComponentToken } from '../../utils/table-token';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class DataTableRowWrapperComponent {
    set rowIndex(val) {
        this._rowIndex = val;
        this.rowContext.rowIndex = val;
        this.groupContext.rowIndex = val;
        this.cd.markForCheck();
    }
    get rowIndex() {
        return this._rowIndex;
    }
    set expanded(val) {
        this._expanded = val;
        this.groupContext.expanded = val;
        this.rowContext.expanded = val;
        this.cd.markForCheck();
    }
    get expanded() {
        return this._expanded;
    }
    constructor(cd, differs, iterableDiffers) {
        this.cd = cd;
        this.differs = differs;
        this.iterableDiffers = iterableDiffers;
        this.rowContextmenu = new EventEmitter(false);
        this.selectedGroupRows = [];
        this._expanded = false;
        this.tableComponent = inject(DatatableComponentToken);
        this.groupContext = {
            group: this.row,
            expanded: this.expanded,
            rowIndex: this.rowIndex
        };
        this.rowContext = {
            row: this.row,
            expanded: this.expanded,
            rowIndex: this.rowIndex
        };
        this.rowDiffer = differs.find({}).create();
        this.selectedRowsDiffer = this.iterableDiffers.find(this.selected ?? []).create();
    }
    ngOnInit() {
        if (this.disableCheck) {
            const isRowDisabled = this.disableCheck(this.row);
            this.disable$ = new BehaviorSubject(isRowDisabled);
        }
        this.rowContext.disableRow$ = this.disable$;
    }
    ngDoCheck() {
        if (this.disableCheck) {
            const isRowDisabled = this.disableCheck(this.row);
            this.disable$.next(isRowDisabled);
            this.cd.markForCheck();
        }
        if (this.rowDiffer.diff(this.row)) {
            this.rowContext.row = this.row;
            this.groupContext.group = this.row;
            this.cd.markForCheck();
        }
        // When groupheader is used with chechbox we use iterableDiffer
        // on currently selected rows to check if it is modified
        // if any of the row of this group is not present in `selected` rows array
        // mark group header checkbox state as indeterminate
        if (this.groupHeader?.checkboxable && this.selectedRowsDiffer.diff(this.selected)) {
            const selectedRows = this.selected.filter(row => this.row.value.find(item => item === row));
            if (this.checkBoxInput) {
                if (selectedRows.length && selectedRows.length !== this.row.value.length) {
                    this.checkBoxInput.nativeElement.indeterminate = true;
                }
                else {
                    this.checkBoxInput.nativeElement.indeterminate = false;
                }
            }
            this.selectedGroupRows = selectedRows;
        }
    }
    onContextmenu($event) {
        this.rowContextmenu.emit({ event: $event, row: this.row });
    }
    getGroupHeaderStyle() {
        const styles = {};
        styles.transform = 'translate3d(' + this.offsetX + 'px, 0px, 0px)';
        styles['backface-visibility'] = 'hidden';
        styles.width = this.innerWidth + 'px';
        return styles;
    }
    onCheckboxChange(groupSelected) {
        // First remove all rows of this group from `selected`
        this.selected = [...this.selected.filter(row => !this.row.value.find(item => item === row))];
        // If checkbox is checked then add all rows of this group in `selected`
        if (groupSelected) {
            this.selected = [...this.selected, ...this.row.value];
        }
        // Update `selected` of DatatableComponent with newly evaluated `selected`
        this.tableComponent.selected = [...this.selected];
        // Emit select event with updated values
        this.tableComponent.onBodySelect({
            selected: this.selected
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.6", ngImport: i0, type: DataTableRowWrapperComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.KeyValueDiffers }, { token: i0.IterableDiffers }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.0.6", type: DataTableRowWrapperComponent, selector: "datatable-row-wrapper", inputs: { innerWidth: "innerWidth", rowDetail: "rowDetail", groupHeader: "groupHeader", offsetX: "offsetX", detailRowHeight: "detailRowHeight", groupHeaderRowHeight: "groupHeaderRowHeight", row: "row", groupedRows: "groupedRows", disableCheck: "disableCheck", selected: "selected", rowIndex: "rowIndex", expanded: "expanded" }, outputs: { rowContextmenu: "rowContextmenu" }, host: { listeners: { "contextmenu": "onContextmenu($event)" }, classAttribute: "datatable-row-wrapper" }, viewQueries: [{ propertyName: "checkBoxInput", first: true, predicate: ["select"], descendants: true }], ngImport: i0, template: `
    <div
      *ngIf="groupHeader && groupHeader.template"
      [style.height.px]="groupHeaderRowHeight"
      class="datatable-group-header"
      [ngStyle]="getGroupHeaderStyle()"
    >
      <div class="datatable-group-cell">
        <div *ngIf="groupHeader.checkboxable">
          <label
            class="datatable-checkbox"
          >
            <input #select type="checkbox" [checked]="selectedGroupRows.length === row.value.length" (change)="onCheckboxChange(select.checked)" />
          </label>
        </div>
        <ng-template
          *ngIf="groupHeader && groupHeader.template"
          [ngTemplateOutlet]="groupHeader.template"
          [ngTemplateOutletContext]="groupContext"
        >
        </ng-template>
      </div>
    </div>
    <ng-content *ngIf="(groupHeader && groupHeader.template && expanded) || !groupHeader || !groupHeader.template">
    </ng-content>
    <div
      *ngIf="rowDetail && rowDetail.template && expanded"
      [style.height.px]="detailRowHeight"
      class="datatable-row-detail"
    >
      <ng-template
        *ngIf="rowDetail && rowDetail.template"
        [ngTemplateOutlet]="rowDetail.template"
        [ngTemplateOutletContext]="rowContext"
      >
      </ng-template>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.6", ngImport: i0, type: DataTableRowWrapperComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'datatable-row-wrapper',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
    <div
      *ngIf="groupHeader && groupHeader.template"
      [style.height.px]="groupHeaderRowHeight"
      class="datatable-group-header"
      [ngStyle]="getGroupHeaderStyle()"
    >
      <div class="datatable-group-cell">
        <div *ngIf="groupHeader.checkboxable">
          <label
            class="datatable-checkbox"
          >
            <input #select type="checkbox" [checked]="selectedGroupRows.length === row.value.length" (change)="onCheckboxChange(select.checked)" />
          </label>
        </div>
        <ng-template
          *ngIf="groupHeader && groupHeader.template"
          [ngTemplateOutlet]="groupHeader.template"
          [ngTemplateOutletContext]="groupContext"
        >
        </ng-template>
      </div>
    </div>
    <ng-content *ngIf="(groupHeader && groupHeader.template && expanded) || !groupHeader || !groupHeader.template">
    </ng-content>
    <div
      *ngIf="rowDetail && rowDetail.template && expanded"
      [style.height.px]="detailRowHeight"
      class="datatable-row-detail"
    >
      <ng-template
        *ngIf="rowDetail && rowDetail.template"
        [ngTemplateOutlet]="rowDetail.template"
        [ngTemplateOutletContext]="rowContext"
      >
      </ng-template>
    </div>
  `,
                    host: {
                        class: 'datatable-row-wrapper'
                    }
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.KeyValueDiffers }, { type: i0.IterableDiffers }], propDecorators: { checkBoxInput: [{
                type: ViewChild,
                args: ['select']
            }], innerWidth: [{
                type: Input
            }], rowDetail: [{
                type: Input
            }], groupHeader: [{
                type: Input
            }], offsetX: [{
                type: Input
            }], detailRowHeight: [{
                type: Input
            }], groupHeaderRowHeight: [{
                type: Input
            }], row: [{
                type: Input
            }], groupedRows: [{
                type: Input
            }], disableCheck: [{
                type: Input
            }], selected: [{
                type: Input
            }], rowContextmenu: [{
                type: Output
            }], rowIndex: [{
                type: Input
            }], expanded: [{
                type: Input
            }], onContextmenu: [{
                type: HostListener,
                args: ['contextmenu', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9keS1yb3ctd3JhcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtZGF0YXRhYmxlL3NyYy9saWIvY29tcG9uZW50cy9ib2R5L2JvZHktcm93LXdyYXBwZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUdULFlBQVksRUFDWixZQUFZLEVBQ1osTUFBTSxFQUNOLEtBQUssRUFNTCxNQUFNLEVBQ04sU0FBUyxFQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdkMsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0seUJBQXlCLENBQUM7OztBQStDbEUsTUFBTSxPQUFPLDRCQUE0QjtJQWN2QyxJQUFhLFFBQVEsQ0FBQyxHQUFXO1FBQy9CLElBQUksQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQztRQUMvQixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsR0FBRyxHQUFHLENBQUM7UUFDakMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3hCLENBQUM7SUFJRCxJQUFhLFFBQVEsQ0FBQyxHQUFZO1FBQ2hDLElBQUksQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQztRQUNqQyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsR0FBRyxHQUFHLENBQUM7UUFDL0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsSUFB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RFosWUFBWTt1QkFBQyxhQUFhLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRG9DaGVjayxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0TGlzdGVuZXIsXG4gIGluamVjdCxcbiAgSW5wdXQsXG4gIEl0ZXJhYmxlRGlmZmVyLFxuICBJdGVyYWJsZURpZmZlcnMsXG4gIEtleVZhbHVlRGlmZmVyLFxuICBLZXlWYWx1ZURpZmZlcnMsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERhdGF0YWJsZUNvbXBvbmVudFRva2VuIH0gZnJvbSAnLi4vLi4vdXRpbHMvdGFibGUtdG9rZW4nO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkYXRhdGFibGUtcm93LXdyYXBwZXInLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2XG4gICAgICAqbmdJZj1cImdyb3VwSGVhZGVyICYmIGdyb3VwSGVhZGVyLnRlbXBsYXRlXCJcbiAgICAgIFtzdHlsZS5oZWlnaHQucHhdPVwiZ3JvdXBIZWFkZXJSb3dIZWlnaHRcIlxuICAgICAgY2xhc3M9XCJkYXRhdGFibGUtZ3JvdXAtaGVhZGVyXCJcbiAgICAgIFtuZ1N0eWxlXT1cImdldEdyb3VwSGVhZGVyU3R5bGUoKVwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cImRhdGF0YWJsZS1ncm91cC1jZWxsXCI+XG4gICAgICAgIDxkaXYgKm5nSWY9XCJncm91cEhlYWRlci5jaGVja2JveGFibGVcIj5cbiAgICAgICAgICA8bGFiZWxcbiAgICAgICAgICAgIGNsYXNzPVwiZGF0YXRhYmxlLWNoZWNrYm94XCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aW5wdXQgI3NlbGVjdCB0eXBlPVwiY2hlY2tib3hcIiBbY2hlY2tlZF09XCJzZWxlY3RlZEdyb3VwUm93cy5sZW5ndGggPT09IHJvdy52YWx1ZS5sZW5ndGhcIiAoY2hhbmdlKT1cIm9uQ2hlY2tib3hDaGFuZ2Uoc2VsZWN0LmNoZWNrZWQpXCIgLz5cbiAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgKm5nSWY9XCJncm91cEhlYWRlciAmJiBncm91cEhlYWRlci50ZW1wbGF0ZVwiXG4gICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwiZ3JvdXBIZWFkZXIudGVtcGxhdGVcIlxuICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJncm91cENvbnRleHRcIlxuICAgICAgICA+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8bmctY29udGVudCAqbmdJZj1cIihncm91cEhlYWRlciAmJiBncm91cEhlYWRlci50ZW1wbGF0ZSAmJiBleHBhbmRlZCkgfHwgIWdyb3VwSGVhZGVyIHx8ICFncm91cEhlYWRlci50ZW1wbGF0ZVwiPlxuICAgIDwvbmctY29udGVudD5cbiAgICA8ZGl2XG4gICAgICAqbmdJZj1cInJvd0RldGFpbCAmJiByb3dEZXRhaWwudGVtcGxhdGUgJiYgZXhwYW5kZWRcIlxuICAgICAgW3N0eWxlLmhlaWdodC5weF09XCJkZXRhaWxSb3dIZWlnaHRcIlxuICAgICAgY2xhc3M9XCJkYXRhdGFibGUtcm93LWRldGFpbFwiXG4gICAgPlxuICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICpuZ0lmPVwicm93RGV0YWlsICYmIHJvd0RldGFpbC50ZW1wbGF0ZVwiXG4gICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInJvd0RldGFpbC50ZW1wbGF0ZVwiXG4gICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJyb3dDb250ZXh0XCJcbiAgICAgID5cbiAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG4gIGAsXG4gIGhvc3Q6IHtcbiAgICBjbGFzczogJ2RhdGF0YWJsZS1yb3ctd3JhcHBlcidcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBEYXRhVGFibGVSb3dXcmFwcGVyQ29tcG9uZW50IGltcGxlbWVudHMgRG9DaGVjaywgT25Jbml0IHtcbiAgQFZpZXdDaGlsZCgnc2VsZWN0JykgY2hlY2tCb3hJbnB1dCE6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD47XG4gIEBJbnB1dCgpIGlubmVyV2lkdGg6IG51bWJlcjtcbiAgQElucHV0KCkgcm93RGV0YWlsOiBhbnk7XG4gIEBJbnB1dCgpIGdyb3VwSGVhZGVyOiBhbnk7XG4gIEBJbnB1dCgpIG9mZnNldFg6IG51bWJlcjtcbiAgQElucHV0KCkgZGV0YWlsUm93SGVpZ2h0OiBhbnk7XG4gIEBJbnB1dCgpIGdyb3VwSGVhZGVyUm93SGVpZ2h0OiBudW1iZXI7XG4gIEBJbnB1dCgpIHJvdzogYW55O1xuICBASW5wdXQoKSBncm91cGVkUm93czogYW55O1xuICBASW5wdXQoKSBkaXNhYmxlQ2hlY2s6IChyb3c6IGFueSkgPT4gYm9vbGVhbjtcbiAgQElucHV0KCkgc2VsZWN0ZWQ6IGFueVtdO1xuICBAT3V0cHV0KCkgcm93Q29udGV4dG1lbnUgPSBuZXcgRXZlbnRFbWl0dGVyPHsgZXZlbnQ6IE1vdXNlRXZlbnQ7IHJvdzogYW55IH0+KGZhbHNlKTtcblxuICBASW5wdXQoKSBzZXQgcm93SW5kZXgodmFsOiBudW1iZXIpIHtcbiAgICB0aGlzLl9yb3dJbmRleCA9IHZhbDtcbiAgICB0aGlzLnJvd0NvbnRleHQucm93SW5kZXggPSB2YWw7XG4gICAgdGhpcy5ncm91cENvbnRleHQucm93SW5kZXggPSB2YWw7XG4gICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIGdldCByb3dJbmRleCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9yb3dJbmRleDtcbiAgfVxuXG4gIHNlbGVjdGVkR3JvdXBSb3dzID0gW107XG5cbiAgQElucHV0KCkgc2V0IGV4cGFuZGVkKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuX2V4cGFuZGVkID0gdmFsO1xuICAgIHRoaXMuZ3JvdXBDb250ZXh0LmV4cGFuZGVkID0gdmFsO1xuICAgIHRoaXMucm93Q29udGV4dC5leHBhbmRlZCA9IHZhbDtcbiAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgfVxuXG4gIGdyb3VwQ29udGV4dDogYW55O1xuICByb3dDb250ZXh0OiBhbnk7XG4gIGRpc2FibGUkOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj47XG5cblxuICBwcml2YXRlIHJvd0RpZmZlcjogS2V5VmFsdWVEaWZmZXI8dW5rbm93biwgdW5rbm93bj47XG4gIHByaXZhdGUgc2VsZWN0ZWRSb3dzRGlmZmVyOiBJdGVyYWJsZURpZmZlcjx1bmtub3duW10+O1xuICBwcml2YXRlIF9leHBhbmRlZCA9IGZhbHNlO1xuICBwcml2YXRlIF9yb3dJbmRleDogbnVtYmVyO1xuICBwcml2YXRlIHRhYmxlQ29tcG9uZW50ID0gaW5qZWN0KERhdGF0YWJsZUNvbXBvbmVudFRva2VuKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiwgcHJpdmF0ZSBkaWZmZXJzOiBLZXlWYWx1ZURpZmZlcnMsIHByaXZhdGUgaXRlcmFibGVEaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMpIHtcbiAgICB0aGlzLmdyb3VwQ29udGV4dCA9IHtcbiAgICAgIGdyb3VwOiB0aGlzLnJvdyxcbiAgICAgIGV4cGFuZGVkOiB0aGlzLmV4cGFuZGVkLFxuICAgICAgcm93SW5kZXg6IHRoaXMucm93SW5kZXhcbiAgICB9O1xuXG4gICAgdGhpcy5yb3dDb250ZXh0ID0ge1xuICAgICAgcm93OiB0aGlzLnJvdyxcbiAgICAgIGV4cGFuZGVkOiB0aGlzLmV4cGFuZGVkLFxuICAgICAgcm93SW5kZXg6IHRoaXMucm93SW5kZXhcbiAgICB9O1xuXG4gICAgdGhpcy5yb3dEaWZmZXIgPSBkaWZmZXJzLmZpbmQoe30pLmNyZWF0ZSgpO1xuICAgIHRoaXMuc2VsZWN0ZWRSb3dzRGlmZmVyID0gdGhpcy5pdGVyYWJsZURpZmZlcnMuZmluZCh0aGlzLnNlbGVjdGVkID8/IFtdKS5jcmVhdGUoKTtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRpc2FibGVDaGVjaykge1xuICAgICAgY29uc3QgaXNSb3dEaXNhYmxlZCA9IHRoaXMuZGlzYWJsZUNoZWNrKHRoaXMucm93KTtcbiAgICAgIHRoaXMuZGlzYWJsZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGlzUm93RGlzYWJsZWQpO1xuICAgIH1cbiAgICB0aGlzLnJvd0NvbnRleHQuZGlzYWJsZVJvdyQgPSB0aGlzLmRpc2FibGUkO1xuICB9XG5cbiAgbmdEb0NoZWNrKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRpc2FibGVDaGVjaykge1xuICAgICAgY29uc3QgaXNSb3dEaXNhYmxlZCA9IHRoaXMuZGlzYWJsZUNoZWNrKHRoaXMucm93KTtcbiAgICAgIHRoaXMuZGlzYWJsZSQubmV4dChpc1Jvd0Rpc2FibGVkKTtcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvd0RpZmZlci5kaWZmKHRoaXMucm93KSkge1xuICAgICAgdGhpcy5yb3dDb250ZXh0LnJvdyA9IHRoaXMucm93O1xuICAgICAgdGhpcy5ncm91cENvbnRleHQuZ3JvdXAgPSB0aGlzLnJvdztcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8vIFdoZW4gZ3JvdXBoZWFkZXIgaXMgdXNlZCB3aXRoIGNoZWNoYm94IHdlIHVzZSBpdGVyYWJsZURpZmZlclxuICAgIC8vIG9uIGN1cnJlbnRseSBzZWxlY3RlZCByb3dzIHRvIGNoZWNrIGlmIGl0IGlzIG1vZGlmaWVkXG4gICAgLy8gaWYgYW55IG9mIHRoZSByb3cgb2YgdGhpcyBncm91cCBpcyBub3QgcHJlc2VudCBpbiBgc2VsZWN0ZWRgIHJvd3MgYXJyYXlcbiAgICAvLyBtYXJrIGdyb3VwIGhlYWRlciBjaGVja2JveCBzdGF0ZSBhcyBpbmRldGVybWluYXRlXG4gICAgaWYgKHRoaXMuZ3JvdXBIZWFkZXI/LmNoZWNrYm94YWJsZSAmJiB0aGlzLnNlbGVjdGVkUm93c0RpZmZlci5kaWZmKHRoaXMuc2VsZWN0ZWQpKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFJvd3MgPSB0aGlzLnNlbGVjdGVkLmZpbHRlcihyb3cgPT4gdGhpcy5yb3cudmFsdWUuZmluZChpdGVtID0+IGl0ZW0gPT09IHJvdykpO1xuICAgICAgaWYgKHRoaXMuY2hlY2tCb3hJbnB1dCkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRSb3dzLmxlbmd0aCAmJiBzZWxlY3RlZFJvd3MubGVuZ3RoICE9PSB0aGlzLnJvdy52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrQm94SW5wdXQubmF0aXZlRWxlbWVudC5pbmRldGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNoZWNrQm94SW5wdXQubmF0aXZlRWxlbWVudC5pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VsZWN0ZWRHcm91cFJvd3MgPSBzZWxlY3RlZFJvd3M7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignY29udGV4dG1lbnUnLCBbJyRldmVudCddKVxuICBvbkNvbnRleHRtZW51KCRldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIHRoaXMucm93Q29udGV4dG1lbnUuZW1pdCh7IGV2ZW50OiAkZXZlbnQsIHJvdzogdGhpcy5yb3cgfSk7XG4gIH1cblxuICBnZXRHcm91cEhlYWRlclN0eWxlKCk6IGFueSB7XG4gICAgY29uc3Qgc3R5bGVzID0ge30gYXMgYW55O1xuXG4gICAgc3R5bGVzLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgdGhpcy5vZmZzZXRYICsgJ3B4LCAwcHgsIDBweCknO1xuICAgIHN0eWxlc1snYmFja2ZhY2UtdmlzaWJpbGl0eSddID0gJ2hpZGRlbic7XG4gICAgc3R5bGVzLndpZHRoID0gdGhpcy5pbm5lcldpZHRoICsgJ3B4JztcbiAgICByZXR1cm4gc3R5bGVzO1xuICB9XG5cbiAgb25DaGVja2JveENoYW5nZShncm91cFNlbGVjdGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgLy8gRmlyc3QgcmVtb3ZlIGFsbCByb3dzIG9mIHRoaXMgZ3JvdXAgZnJvbSBgc2VsZWN0ZWRgXG4gICAgdGhpcy5zZWxlY3RlZCA9IFsuLi50aGlzLnNlbGVjdGVkLmZpbHRlcihyb3cgPT4gIXRoaXMucm93LnZhbHVlLmZpbmQoaXRlbSA9PiBpdGVtID09PSByb3cpKV07XG4gICAgLy8gSWYgY2hlY2tib3ggaXMgY2hlY2tlZCB0aGVuIGFkZCBhbGwgcm93cyBvZiB0aGlzIGdyb3VwIGluIGBzZWxlY3RlZGBcbiAgICBpZiAoZ3JvdXBTZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IFsuLi50aGlzLnNlbGVjdGVkLCAuLi50aGlzLnJvdy52YWx1ZV07XG4gICAgfVxuICAgIC8vIFVwZGF0ZSBgc2VsZWN0ZWRgIG9mIERhdGF0YWJsZUNvbXBvbmVudCB3aXRoIG5ld2x5IGV2YWx1YXRlZCBgc2VsZWN0ZWRgXG4gICAgdGhpcy50YWJsZUNvbXBvbmVudC5zZWxlY3RlZCA9IFsuLi50aGlzLnNlbGVjdGVkXTtcbiAgICAvLyBFbWl0IHNlbGVjdCBldmVudCB3aXRoIHVwZGF0ZWQgdmFsdWVzXG4gICAgdGhpcy50YWJsZUNvbXBvbmVudC5vbkJvZHlTZWxlY3Qoe1xuICAgICAgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWRcbiAgICB9KTtcbiAgfVxufVxuIl19