import { getterForProp } from './column-prop-getters';
import { SortType } from '../types/sort.type';
import { SortDirection } from '../types/sort-direction.type';
/**
 * Gets the next sort direction
 */
export function nextSortDir(sortType, current) {
    if (sortType === SortType.single) {
        if (current === SortDirection.asc) {
            return SortDirection.desc;
        }
        else {
            return SortDirection.asc;
        }
    }
    else {
        if (!current) {
            return SortDirection.asc;
        }
        else if (current === SortDirection.asc) {
            return SortDirection.desc;
        }
        else if (current === SortDirection.desc) {
            return undefined;
        }
        // avoid TS7030: Not all code paths return a value.
        return undefined;
    }
}
/**
 * Adapted from fueld-ui on 6/216
 * https://github.com/FuelInteractive/fuel-ui/tree/master/src/pipes/OrderBy
 */
export function orderByComparator(a, b) {
    if (a === null || typeof a === 'undefined') {
        a = 0;
    }
    if (b === null || typeof b === 'undefined') {
        b = 0;
    }
    if (a instanceof Date && b instanceof Date) {
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
    }
    else if (isNaN(parseFloat(a)) || !isFinite(a) || isNaN(parseFloat(b)) || !isFinite(b)) {
        // Convert to string in case of a=0 or b=0
        a = String(a);
        b = String(b);
        // Isn't a number so lowercase the string to properly compare
        if (a.toLowerCase() < b.toLowerCase()) {
            return -1;
        }
        if (a.toLowerCase() > b.toLowerCase()) {
            return 1;
        }
    }
    else {
        // Parse strings as numbers to compare properly
        if (parseFloat(a) < parseFloat(b)) {
            return -1;
        }
        if (parseFloat(a) > parseFloat(b)) {
            return 1;
        }
    }
    // equal each other
    return 0;
}
/**
 * creates a shallow copy of the `rows` input and returns the sorted copy. this function
 * does not sort the `rows` argument in place
 */
export function sortRows(rows, columns, dirs) {
    if (!rows) {
        return [];
    }
    if (!dirs || !dirs.length || !columns) {
        return [...rows];
    }
    /**
     * record the row ordering of results from prior sort operations (if applicable)
     * this is necessary to guarantee stable sorting behavior
     */
    const rowToIndexMap = new Map();
    rows.forEach((row, index) => rowToIndexMap.set(row, index));
    const temp = [...rows];
    const cols = columns.reduce((obj, col) => {
        if (col.comparator && typeof col.comparator === 'function') {
            obj[col.prop] = col.comparator;
        }
        return obj;
    }, {});
    // cache valueGetter and compareFn so that they
    // do not need to be looked-up in the sort function body
    const cachedDirs = dirs.map(dir => {
        const prop = dir.prop;
        return {
            prop,
            dir: dir.dir,
            valueGetter: getterForProp(prop),
            compareFn: cols[prop] || orderByComparator
        };
    });
    return temp.sort(function (rowA, rowB) {
        for (const cachedDir of cachedDirs) {
            // Get property and valuegetters for column to be sorted
            const { prop, valueGetter } = cachedDir;
            // Get A and B cell values from rows based on properties of the columns
            const propA = valueGetter(rowA, prop);
            const propB = valueGetter(rowB, prop);
            // Compare function gets five parameters:
            // Two cell values to be compared as propA and propB
            // Two rows corresponding to the cells as rowA and rowB
            // Direction of the sort for this column as SortDirection
            // Compare can be a standard JS comparison function (a,b) => -1|0|1
            // as additional parameters are silently ignored. The whole row and sort
            // direction enable more complex sort logic.
            const comparison = cachedDir.dir !== SortDirection.desc
                ? cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir)
                : -cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir);
            // Don't return 0 yet in case of needing to sort by next property
            if (comparison !== 0) {
                return comparison;
            }
        }
        if (!(rowToIndexMap.has(rowA) && rowToIndexMap.has(rowB))) {
            return 0;
        }
        /**
         * all else being equal, preserve original order of the rows (stable sort)
         */
        return rowToIndexMap.get(rowA) < rowToIndexMap.get(rowB) ? -1 : 1;
    });
}
export function sortGroupedRows(groupedRows, columns, dirs, sortOnGroupHeader) {
    if (sortOnGroupHeader) {
        groupedRows = sortRows(groupedRows, columns, [{
                dir: sortOnGroupHeader.dir,
                prop: 'key'
            }]);
    }
    return groupedRows.map(group => ({ ...group, value: sortRows(group.value, columns, dirs) }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ydC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1kYXRhdGFibGUvc3JjL2xpYi91dGlscy9zb3J0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDOUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBRTdEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBQyxRQUFrQixFQUFFLE9BQXNCO0lBQ3BFLElBQUksUUFBUSxLQUFLLFFBQVEsQ0FBQyxNQUFNLEVBQUU7UUFDaEMsSUFBSSxPQUFPLEtBQUssYUFBYSxDQUFDLEdBQUcsRUFBRTtZQUNqQyxPQUFPLGFBQWEsQ0FBQyxJQUFJLENBQUM7U0FDM0I7YUFBTTtZQUNMLE9BQU8sYUFBYSxDQUFDLEdBQUcsQ0FBQztTQUMxQjtLQUNGO1NBQU07UUFDTCxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ1osT0FBTyxhQUFhLENBQUMsR0FBRyxDQUFDO1NBQzFCO2FBQU0sSUFBSSxPQUFPLEtBQUssYUFBYSxDQUFDLEdBQUcsRUFBRTtZQUN4QyxPQUFPLGFBQWEsQ0FBQyxJQUFJLENBQUM7U0FDM0I7YUFBTSxJQUFJLE9BQU8sS0FBSyxhQUFhLENBQUMsSUFBSSxFQUFFO1lBQ3pDLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsbURBQW1EO1FBQ25ELE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxDQUFNLEVBQUUsQ0FBTTtJQUM5QyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksT0FBTyxDQUFDLEtBQUssV0FBVyxFQUFFO1FBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUFDO0lBQ3BELElBQUks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QUFDLE9BQU8sQ0FBQyxDQUFDO1NBQUM7UUFFdEU7O1dBRUc7UUFDSCxPQUFPLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwRSxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxNQUFNLFVBQVUsZUFBZSxDQUFDLFdBQWtCLEVBQUUsT0FBYyxFQUFFLElBQW1CLEVBQUUsaUJBQThCO0lBQ3JILElBQUksaUJBQWlCLEVBQUU7UUFDckIsV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLEVBQUUsT0FBTyxFQUFFLENBQUM7Z0JBQzVDLEdBQUcsRUFBRSxpQkFBaUIsQ0FBQyxHQUFHO2dCQUMxQixJQUFJLEVBQUUsS0FBSzthQUNaLENBQUMsQ0FBQyxDQUFDO0tBQ0w7SUFDRCxPQUFPLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxLQUFLLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMvRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0dGVyRm9yUHJvcCB9IGZyb20gJy4vY29sdW1uLXByb3AtZ2V0dGVycyc7XG5pbXBvcnQgeyBTb3J0VHlwZSB9IGZyb20gJy4uL3R5cGVzL3NvcnQudHlwZSc7XG5pbXBvcnQgeyBTb3J0RGlyZWN0aW9uIH0gZnJvbSAnLi4vdHlwZXMvc29ydC1kaXJlY3Rpb24udHlwZSc7XG5pbXBvcnQgeyBTb3J0UHJvcERpciB9IGZyb20gJy4uL3R5cGVzL3NvcnQtcHJvcC1kaXIudHlwZSc7XG4vKipcbiAqIEdldHMgdGhlIG5leHQgc29ydCBkaXJlY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5leHRTb3J0RGlyKHNvcnRUeXBlOiBTb3J0VHlwZSwgY3VycmVudDogU29ydERpcmVjdGlvbik6IFNvcnREaXJlY3Rpb24gfCB1bmRlZmluZWQge1xuICBpZiAoc29ydFR5cGUgPT09IFNvcnRUeXBlLnNpbmdsZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBTb3J0RGlyZWN0aW9uLmFzYykge1xuICAgICAgcmV0dXJuIFNvcnREaXJlY3Rpb24uZGVzYztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFNvcnREaXJlY3Rpb24uYXNjO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybiBTb3J0RGlyZWN0aW9uLmFzYztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IFNvcnREaXJlY3Rpb24uYXNjKSB7XG4gICAgICByZXR1cm4gU29ydERpcmVjdGlvbi5kZXNjO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudCA9PT0gU29ydERpcmVjdGlvbi5kZXNjKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBhdm9pZCBUUzcwMzA6IE5vdCBhbGwgY29kZSBwYXRocyByZXR1cm4gYSB2YWx1ZS5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogQWRhcHRlZCBmcm9tIGZ1ZWxkLXVpIG9uIDYvMjE2XG4gKiBodHRwczovL2dpdGh1Yi5jb20vRnVlbEludGVyYWN0aXZlL2Z1ZWwtdWkvdHJlZS9tYXN0ZXIvc3JjL3BpcGVzL09yZGVyQnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yZGVyQnlDb21wYXJhdG9yKGE6IGFueSwgYjogYW55KTogbnVtYmVyIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnKSB7YSA9IDA7fVxuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpIHtiID0gMDt9XG4gIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIGlmIChhIDwgYikge3JldHVybiAtMTt9XG4gICAgaWYgKGEgPiBiKSB7cmV0dXJuIDE7fVxuICB9IGVsc2UgaWYgKGlzTmFOKHBhcnNlRmxvYXQoYSkpIHx8ICFpc0Zpbml0ZShhKSB8fCBpc05hTihwYXJzZUZsb2F0KGIpKSB8fCAhaXNGaW5pdGUoYikpIHtcbiAgICAvLyBDb252ZXJ0IHRvIHN0cmluZyBpbiBjYXNlIG9mIGE9MCBvciBiPTBcbiAgICBhID0gU3RyaW5nKGEpO1xuICAgIGIgPSBTdHJpbmcoYik7XG4gICAgLy8gSXNuJ3QgYSBudW1iZXIgc28gbG93ZXJjYXNlIHRoZSBzdHJpbmcgdG8gcHJvcGVybHkgY29tcGFyZVxuICAgIGlmIChhLnRvTG93ZXJDYXNlKCkgPCBiLnRvTG93ZXJDYXNlKCkpIHtyZXR1cm4gLTE7fVxuICAgIGlmIChhLnRvTG93ZXJDYXNlKCkgPiBiLnRvTG93ZXJDYXNlKCkpIHtyZXR1cm4gMTt9XG4gIH0gZWxzZSB7XG4gICAgLy8gUGFyc2Ugc3RyaW5ncyBhcyBudW1iZXJzIHRvIGNvbXBhcmUgcHJvcGVybHlcbiAgICBpZiAocGFyc2VGbG9hdChhKSA8IHBhcnNlRmxvYXQoYikpIHtyZXR1cm4gLTE7fVxuICAgIGlmIChwYXJzZUZsb2F0KGEpID4gcGFyc2VGbG9hdChiKSkge3JldHVybiAxO31cbiAgfVxuXG4gIC8vIGVxdWFsIGVhY2ggb3RoZXJcbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogY3JlYXRlcyBhIHNoYWxsb3cgY29weSBvZiB0aGUgYHJvd3NgIGlucHV0IGFuZCByZXR1cm5zIHRoZSBzb3J0ZWQgY29weS4gdGhpcyBmdW5jdGlvblxuICogZG9lcyBub3Qgc29ydCB0aGUgYHJvd3NgIGFyZ3VtZW50IGluIHBsYWNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0Um93cyhyb3dzOiBhbnlbXSwgY29sdW1uczogYW55W10sIGRpcnM6IFNvcnRQcm9wRGlyW10pOiBhbnlbXSB7XG4gIGlmICghcm93cykge3JldHVybiBbXTt9XG4gIGlmICghZGlycyB8fCAhZGlycy5sZW5ndGggfHwgIWNvbHVtbnMpIHtyZXR1cm4gWy4uLnJvd3NdO31cblxuICAvKipcbiAgICogcmVjb3JkIHRoZSByb3cgb3JkZXJpbmcgb2YgcmVzdWx0cyBmcm9tIHByaW9yIHNvcnQgb3BlcmF0aW9ucyAoaWYgYXBwbGljYWJsZSlcbiAgICogdGhpcyBpcyBuZWNlc3NhcnkgdG8gZ3VhcmFudGVlIHN0YWJsZSBzb3J0aW5nIGJlaGF2aW9yXG4gICAqL1xuICBjb25zdCByb3dUb0luZGV4TWFwID0gbmV3IE1hcDxhbnksIG51bWJlcj4oKTtcbiAgcm93cy5mb3JFYWNoKChyb3csIGluZGV4KSA9PiByb3dUb0luZGV4TWFwLnNldChyb3csIGluZGV4KSk7XG5cbiAgY29uc3QgdGVtcCA9IFsuLi5yb3dzXTtcbiAgY29uc3QgY29scyA9IGNvbHVtbnMucmVkdWNlKChvYmosIGNvbCkgPT4ge1xuICAgIGlmIChjb2wuY29tcGFyYXRvciAmJiB0eXBlb2YgY29sLmNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9ialtjb2wucHJvcF0gPSBjb2wuY29tcGFyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xuXG4gIC8vIGNhY2hlIHZhbHVlR2V0dGVyIGFuZCBjb21wYXJlRm4gc28gdGhhdCB0aGV5XG4gIC8vIGRvIG5vdCBuZWVkIHRvIGJlIGxvb2tlZC11cCBpbiB0aGUgc29ydCBmdW5jdGlvbiBib2R5XG4gIGNvbnN0IGNhY2hlZERpcnMgPSBkaXJzLm1hcChkaXIgPT4ge1xuICAgIGNvbnN0IHByb3AgPSBkaXIucHJvcDtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcCxcbiAgICAgIGRpcjogZGlyLmRpcixcbiAgICAgIHZhbHVlR2V0dGVyOiBnZXR0ZXJGb3JQcm9wKHByb3ApLFxuICAgICAgY29tcGFyZUZuOiBjb2xzW3Byb3BdIHx8IG9yZGVyQnlDb21wYXJhdG9yXG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRlbXAuc29ydChmdW5jdGlvbihyb3dBOiBhbnksIHJvd0I6IGFueSkge1xuICAgIGZvciAoY29uc3QgY2FjaGVkRGlyIG9mIGNhY2hlZERpcnMpIHtcbiAgICAgIC8vIEdldCBwcm9wZXJ0eSBhbmQgdmFsdWVnZXR0ZXJzIGZvciBjb2x1bW4gdG8gYmUgc29ydGVkXG4gICAgICBjb25zdCB7IHByb3AsIHZhbHVlR2V0dGVyIH0gPSBjYWNoZWREaXI7XG4gICAgICAvLyBHZXQgQSBhbmQgQiBjZWxsIHZhbHVlcyBmcm9tIHJvd3MgYmFzZWQgb24gcHJvcGVydGllcyBvZiB0aGUgY29sdW1uc1xuICAgICAgY29uc3QgcHJvcEEgPSB2YWx1ZUdldHRlcihyb3dBLCBwcm9wKTtcbiAgICAgIGNvbnN0IHByb3BCID0gdmFsdWVHZXR0ZXIocm93QiwgcHJvcCk7XG5cbiAgICAgIC8vIENvbXBhcmUgZnVuY3Rpb24gZ2V0cyBmaXZlIHBhcmFtZXRlcnM6XG4gICAgICAvLyBUd28gY2VsbCB2YWx1ZXMgdG8gYmUgY29tcGFyZWQgYXMgcHJvcEEgYW5kIHByb3BCXG4gICAgICAvLyBUd28gcm93cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjZWxscyBhcyByb3dBIGFuZCByb3dCXG4gICAgICAvLyBEaXJlY3Rpb24gb2YgdGhlIHNvcnQgZm9yIHRoaXMgY29sdW1uIGFzIFNvcnREaXJlY3Rpb25cbiAgICAgIC8vIENvbXBhcmUgY2FuIGJlIGEgc3RhbmRhcmQgSlMgY29tcGFyaXNvbiBmdW5jdGlvbiAoYSxiKSA9PiAtMXwwfDFcbiAgICAgIC8vIGFzIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBhcmUgc2lsZW50bHkgaWdub3JlZC4gVGhlIHdob2xlIHJvdyBhbmQgc29ydFxuICAgICAgLy8gZGlyZWN0aW9uIGVuYWJsZSBtb3JlIGNvbXBsZXggc29ydCBsb2dpYy5cbiAgICAgIGNvbnN0IGNvbXBhcmlzb24gPVxuICAgICAgICBjYWNoZWREaXIuZGlyICE9PSBTb3J0RGlyZWN0aW9uLmRlc2NcbiAgICAgICAgICA/IGNhY2hlZERpci5jb21wYXJlRm4ocHJvcEEsIHByb3BCLCByb3dBLCByb3dCLCBjYWNoZWREaXIuZGlyKVxuICAgICAgICAgIDogLWNhY2hlZERpci5jb21wYXJlRm4ocHJvcEEsIHByb3BCLCByb3dBLCByb3dCLCBjYWNoZWREaXIuZGlyKTtcblxuICAgICAgLy8gRG9uJ3QgcmV0dXJuIDAgeWV0IGluIGNhc2Ugb2YgbmVlZGluZyB0byBzb3J0IGJ5IG5leHQgcHJvcGVydHlcbiAgICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7cmV0dXJuIGNvbXBhcmlzb247fVxuICAgIH1cblxuICAgIGlmICghKHJvd1RvSW5kZXhNYXAuaGFzKHJvd0EpICYmIHJvd1RvSW5kZXhNYXAuaGFzKHJvd0IpKSkge3JldHVybiAwO31cblxuICAgIC8qKlxuICAgICAqIGFsbCBlbHNlIGJlaW5nIGVxdWFsLCBwcmVzZXJ2ZSBvcmlnaW5hbCBvcmRlciBvZiB0aGUgcm93cyAoc3RhYmxlIHNvcnQpXG4gICAgICovXG4gICAgcmV0dXJuIHJvd1RvSW5kZXhNYXAuZ2V0KHJvd0EpIDwgcm93VG9JbmRleE1hcC5nZXQocm93QikgPyAtMSA6IDE7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc29ydEdyb3VwZWRSb3dzKGdyb3VwZWRSb3dzOiBhbnlbXSwgY29sdW1uczogYW55W10sIGRpcnM6IFNvcnRQcm9wRGlyW10sIHNvcnRPbkdyb3VwSGVhZGVyOiBTb3J0UHJvcERpcik6IGFueVtdIHtcbiAgaWYgKHNvcnRPbkdyb3VwSGVhZGVyKSB7XG4gICAgZ3JvdXBlZFJvd3MgPSBzb3J0Um93cyhncm91cGVkUm93cywgY29sdW1ucywgW3tcbiAgICAgIGRpcjogc29ydE9uR3JvdXBIZWFkZXIuZGlyLFxuICAgICAgcHJvcDogJ2tleSdcbiAgICB9XSk7XG4gIH1cbiAgcmV0dXJuIGdyb3VwZWRSb3dzLm1hcChncm91cCA9PiAoeyAuLi5ncm91cCwgdmFsdWU6IHNvcnRSb3dzKGdyb3VwLnZhbHVlLCBjb2x1bW5zLCBkaXJzKSB9KSk7XG59XG4iXX0=