import { Directive, Input, Output, inject, signal, effect, computed, numberAttribute, booleanAttribute, runInInjectionContext, input, EventEmitter, ElementRef, NgZone, Injector } from '@angular/core';
import { Platform } from '@angular/cdk/platform';
import { Directionality } from '@angular/cdk/bidi';
import { toSignal } from '@angular/core/rxjs-interop';
import { map, tap } from 'rxjs';
import { SmoothScrollManager } from 'ngx-scrollbar/smooth-scroll';
import { NG_SCROLLBAR } from './utils/scrollbar-base';
import { resizeObserver, ViewportAdapter } from './viewport';
import { ScrollbarUpdateReason, NG_SCROLLBAR_OPTIONS } from './ng-scrollbar.model';
import * as i0 from "@angular/core";
export class NgScrollbarCore {
    constructor() {
        /** Global options */
        this.options = inject(NG_SCROLLBAR_OPTIONS);
        this.zone = inject(NgZone);
        this.platform = inject(Platform);
        this.injector = inject(Injector);
        /** A flag that indicates if the platform is mobile */
        this.isMobile = this.platform.IOS || this.platform.ANDROID;
        this.dir = inject(Directionality);
        this.smoothScroll = inject(SmoothScrollManager);
        this.nativeElement = inject((ElementRef)).nativeElement;
        /**
         * Indicates when scrollbar thumb is being dragged
         */
        this.dragging = signal('none');
        /**
         * Sets the supported scroll track of the viewport, there are 3 options:
         *
         * - `vertical` Use both vertical and horizontal scrollbar
         * - `horizontal` Use both vertical and horizontal scrollbar
         * - `auto` Use both vertical and horizontal scrollbar
         */
        this.orientation = input(this.options.orientation);
        /**
         * When to show the scrollbar, and there are 3 options:
         *
         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
         * - `always` Scrollbars are always shown even if the viewport is not scrollable
         */
        this.visibility = input(this.options.visibility);
        /** Show scrollbar buttons */
        this.buttons = input(this.options.buttons, {
            transform: booleanAttribute
        });
        /** Disables scrollbar interaction like dragging thumb and jumping by track click */
        this.disableInteraction = input(this.options.disableInteraction, {
            transform: booleanAttribute
        });
        /** Whether ResizeObserver is disabled */
        this.disableSensor = input(this.options.disableSensor, {
            transform: booleanAttribute
        });
        /** Throttle interval for detecting changes via ResizeObserver */
        this.sensorThrottleTime = input(this.options.sensorThrottleTime, {
            transform: numberAttribute
        });
        /** A flag used to activate hover effect on the offset area around the scrollbar */
        this.hoverOffset = input(this.options.hoverOffset, {
            transform: booleanAttribute
        });
        this.viewportDimension = signal({
            contentHeight: 0,
            contentWidth: 0,
            offsetHeight: 0,
            offsetWidth: 0
        });
        this.state = computed(() => {
            let verticalUsed = false;
            let horizontalUsed = false;
            let isVerticallyScrollable = false;
            let isHorizontallyScrollable = false;
            const orientation = this.orientation();
            const visibility = this.visibility();
            const viewport = this.viewportDimension();
            // Check if vertical scrollbar should be displayed
            if (orientation === 'auto' || orientation === 'vertical') {
                isVerticallyScrollable = viewport.contentHeight > viewport.offsetHeight;
                verticalUsed = visibility === 'visible' || isVerticallyScrollable;
            }
            // Check if horizontal scrollbar should be displayed
            if (orientation === 'auto' || orientation === 'horizontal') {
                isHorizontallyScrollable = viewport.contentWidth > viewport.offsetWidth;
                horizontalUsed = visibility === 'visible' || isHorizontallyScrollable;
            }
            return {
                verticalUsed,
                horizontalUsed,
                isVerticallyScrollable,
                isHorizontallyScrollable,
            };
        });
        this.isVerticallyScrollable = computed(() => this.state().isVerticallyScrollable);
        this.isHorizontallyScrollable = computed(() => this.state().isHorizontallyScrollable);
        this.verticalUsed = computed(() => this.state().verticalUsed);
        this.horizontalUsed = computed(() => this.state().horizontalUsed);
        /** Scroll duration when the scroll track is clicked */
        this.trackScrollDuration = this.options.trackScrollDuration;
        /**
         *  Sets the appearance of the scrollbar, there are 2 options:
         *
         * - `native` (default) scrollbar space will be reserved just like with native scrollbar.
         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
         */
        this.appearance = this.options.appearance;
        /**
         * Sets the position of each scrollbar, there are 4 options:
         *
         * - `native` (Default) Use the default position like in native scrollbar.
         * - `invertY` Inverts vertical scrollbar position
         * - `invertX` Inverts Horizontal scrollbar position
         * - `invertAll` Inverts both scrollbar positions
         */
        this.position = this.options.position;
        /** A class forwarded to the scrollbar track element */
        this.trackClass = this.options.trackClass;
        /** A class forwarded to the scrollbar thumb element */
        this.thumbClass = this.options.thumbClass;
        /** A class forwarded to the scrollbar button element */
        this.buttonClass = this.options.thumbClass;
        /** Steam that emits when scrollbar is initialized */
        this.afterInit = new EventEmitter();
        /** Steam that emits when scrollbar is updated */
        this.afterUpdate = new EventEmitter();
        /** Viewport adapter instance */
        this.viewport = new ViewportAdapter();
    }
    ngOnInit() {
        runInInjectionContext(this.injector, () => {
            // The direction signal cannot be initialized in the constructor
            // Because it initially returns 'ltr' even if dir.value is 'rtl`, the map function here is crucial
            this.direction = toSignal(this.dir.change.pipe(map(() => this.dir.value)), { initialValue: this.dir.value });
            effect((onCleanup) => {
                // Check whether sensor should be enabled
                if (this.disableSensor()) {
                    // If sensor is disabled update manually
                    this.sizeChangeSub?.unsubscribe();
                }
                else {
                    if (this.platform.isBrowser && this.viewport.initialized()) {
                        this.sizeChangeSub?.unsubscribe();
                        this.zone.runOutsideAngular(() => {
                            this.sizeChangeSub = resizeObserver({
                                element: this.viewport.nativeElement,
                                contentWrapper: this.viewport.contentWrapperElement,
                                throttleDuration: this.sensorThrottleTime()
                            }).pipe(tap((reason) => this.update(reason))).subscribe();
                        });
                    }
                }
                onCleanup(() => this.sizeChangeSub?.unsubscribe());
            });
        });
    }
    ngAfterViewInit() {
        // If sensor is disabled, update to evaluate the state
        if (this.platform.isBrowser && this.disableSensor()) {
            // In case of 3rd party library, need to wait for content to be rendered
            requestAnimationFrame(() => {
                this.update(ScrollbarUpdateReason.AfterInit);
            });
        }
    }
    /**
     * Update local state and the internal scrollbar controls
     */
    update(reason) {
        this.updateCSSVariables();
        this.zone.run(() => {
            this.viewportDimension.set({
                contentHeight: this.viewport.contentHeight,
                contentWidth: this.viewport.contentWidth,
                offsetHeight: this.viewport.offsetHeight,
                offsetWidth: this.viewport.offsetWidth
            });
            // After the upgrade to Angular 18, the effect functions in the inner directives are executed after "afterInit" is emitted,
            // causing the tests to fail. A tiny delay is needed before emitting to the output as a workaround.
            if (reason === ScrollbarUpdateReason.AfterInit) {
                this.afterInit.emit();
            }
            else {
                this.afterUpdate.emit();
            }
        });
    }
    /**
     * Smooth scroll functions
     */
    scrollTo(options) {
        return this.smoothScroll.scrollTo(this.viewport.nativeElement, options);
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(target, options) {
        return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);
    }
    /**
     * Update Essential CSS variables
     */
    updateCSSVariables() {
        this.nativeElement.style.setProperty('--content-height', `${this.viewport.contentHeight}`);
        this.nativeElement.style.setProperty('--content-width', `${this.viewport.contentWidth}`);
        this.nativeElement.style.setProperty('--viewport-height', `${this.viewport.offsetHeight}`);
        this.nativeElement.style.setProperty('--viewport-width', `${this.viewport.offsetWidth}`);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: NgScrollbarCore, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "18.2.1", type: NgScrollbarCore, inputs: { orientation: { classPropertyName: "orientation", publicName: "orientation", isSignal: true, isRequired: false, transformFunction: null }, visibility: { classPropertyName: "visibility", publicName: "visibility", isSignal: true, isRequired: false, transformFunction: null }, buttons: { classPropertyName: "buttons", publicName: "buttons", isSignal: true, isRequired: false, transformFunction: null }, disableInteraction: { classPropertyName: "disableInteraction", publicName: "disableInteraction", isSignal: true, isRequired: false, transformFunction: null }, disableSensor: { classPropertyName: "disableSensor", publicName: "disableSensor", isSignal: true, isRequired: false, transformFunction: null }, sensorThrottleTime: { classPropertyName: "sensorThrottleTime", publicName: "sensorThrottleTime", isSignal: true, isRequired: false, transformFunction: null }, hoverOffset: { classPropertyName: "hoverOffset", publicName: "hoverOffset", isSignal: true, isRequired: false, transformFunction: null }, trackScrollDuration: { classPropertyName: "trackScrollDuration", publicName: "trackScrollDuration", isSignal: false, isRequired: false, transformFunction: numberAttribute }, appearance: { classPropertyName: "appearance", publicName: "appearance", isSignal: false, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: false, isRequired: false, transformFunction: null }, trackClass: { classPropertyName: "trackClass", publicName: "trackClass", isSignal: false, isRequired: false, transformFunction: null }, thumbClass: { classPropertyName: "thumbClass", publicName: "thumbClass", isSignal: false, isRequired: false, transformFunction: null }, buttonClass: { classPropertyName: "buttonClass", publicName: "buttonClass", isSignal: false, isRequired: false, transformFunction: null } }, outputs: { afterInit: "afterInit", afterUpdate: "afterUpdate" }, host: { properties: { "class.ng-scrollbar": "true", "attr.verticalUsed": "verticalUsed()", "attr.horizontalUsed": "horizontalUsed()", "attr.isVerticallyScrollable": "isVerticallyScrollable()", "attr.isHorizontallyScrollable": "isHorizontallyScrollable()", "attr.mobile": "isMobile", "attr.dir": "direction()", "attr.position": "position", "attr.dragging": "dragging()", "attr.appearance": "appearance", "attr.visibility": "visibility()", "attr.orientation": "orientation()", "attr.disableInteraction": "disableInteraction()" } }, providers: [{ provide: NG_SCROLLBAR, useExisting: NgScrollbarCore }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: NgScrollbarCore, decorators: [{
            type: Directive,
            args: [{
                    host: {
                        '[class.ng-scrollbar]': 'true',
                        '[attr.verticalUsed]': 'verticalUsed()',
                        '[attr.horizontalUsed]': 'horizontalUsed()',
                        '[attr.isVerticallyScrollable]': 'isVerticallyScrollable()',
                        '[attr.isHorizontallyScrollable]': 'isHorizontallyScrollable()',
                        '[attr.mobile]': 'isMobile',
                        '[attr.dir]': 'direction()',
                        '[attr.position]': 'position',
                        '[attr.dragging]': 'dragging()',
                        '[attr.appearance]': 'appearance',
                        '[attr.visibility]': 'visibility()',
                        '[attr.orientation]': 'orientation()',
                        '[attr.disableInteraction]': 'disableInteraction()'
                    },
                    providers: [{ provide: NG_SCROLLBAR, useExisting: NgScrollbarCore }]
                }]
        }], propDecorators: { trackScrollDuration: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], appearance: [{
                type: Input
            }], position: [{
                type: Input
            }], trackClass: [{
                type: Input
            }], thumbClass: [{
                type: Input
            }], buttonClass: [{
                type: Input
            }], afterInit: [{
                type: Output
            }], afterUpdate: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctc2Nyb2xsYmFyLWNvcmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc2Nyb2xsYmFyL3NyYy9saWIvbmctc2Nyb2xsYmFyLWNvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLE1BQU0sRUFDTixNQUFNLEVBQ04sTUFBTSxFQUNOLFFBQVEsRUFDUixlQUFlLEVBQ2YsZ0JBQWdCLEVBQ2hCLHFCQUFxQixFQUNyQixLQUFLLEVBQ0wsWUFBWSxFQUdaLFVBQVUsRUFDVixNQUFNLEVBR04sUUFBUSxFQUlULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNqRCxPQUFPLEVBQWEsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDOUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3RELE9BQU8sRUFBZ0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM5QyxPQUFPLEVBRUwsbUJBQW1CLEVBR3BCLE1BQU0sNkJBQTZCLENBQUM7QUFFckMsT0FBTyxFQUFnQixZQUFZLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUU3RCxPQUFPLEVBSUwscUJBQXFCLEVBR3JCLG9CQUFvQixFQUNyQixNQUFNLHNCQUFzQixDQUFDOztBQTJCOUIsTUFBTSxPQUFnQixlQUFlO0lBbEJyQztRQW9CRSxxQkFBcUI7UUFDSixZQUFPLEdBQXVCLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBRTNELFNBQUksR0FBVyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUIsYUFBUSxHQUFhLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN0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ZixlQUFlLDhvQ0FnSGYsZUFBZSx5d0NBbEh4QixDQUFDLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLENBQUM7OzJGQUVoRCxlQUFlO2tCQWxCcEMsU0FBUzttQkFBQztvQkFDVCxJQUFJLEVBQUU7d0JBQ0osc0JBQXNCLEVBQUUsTUFBTTt3QkFDOUIscUJBQXFCLEVBQUUsZ0JBQWdCO3dCQUN2Qyx1QkFBdUIsRUFBRSxrQkFBa0I7d0JBQzNDLCtCQUErQixFQUFFLDBCQUEwQjt3QkFDM0QsaUNBQWlDLEVBQUUsNEJBQTRCO3dCQUMvRCxlQUFlLEVBQUUsVUFBVTt3QkFDM0IsWUFBWSxFQUFFLGFBQWE7d0JBQzNCLGlCQUFpQixFQUFFLFVBQVU7d0JBQzdCLGlCQUFpQixFQUFFLFlBQVk7d0JBQy9CLG1CQUFtQixFQUFFLFlBQVk7d0JBQ2pDLG1CQUFtQixFQUFFLGNBQWM7d0JBQ25DLG9CQUFvQixFQUFFLGVBQWU7d0JBQ3JDLDJCQUEyQixFQUFFLHNCQUFzQjtxQkFDcEQ7b0JBQ0QsU0FBUyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLFdBQVcsaUJBQWlCLEVBQUUsQ0FBQztpQkFDckU7OEJBaUh3QyxtQkFBbUI7c0JBQXpELEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFO2dCQVE1QixVQUFVO3NCQUFsQixLQUFLO2dCQVNHLFFBQVE7c0JBQWhCLEtBQUs7Z0JBR0csVUFBVTtzQkFBbEIsS0FBSztnQkFFRyxVQUFVO3NCQUFsQixLQUFLO2dCQUVHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBR0ksU0FBUztzQkFBbEIsTUFBTTtnQkFHRyxXQUFXO3NCQUFwQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBEaXJlY3RpdmUsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG4gIGluamVjdCxcclxuICBzaWduYWwsXHJcbiAgZWZmZWN0LFxyXG4gIGNvbXB1dGVkLFxyXG4gIG51bWJlckF0dHJpYnV0ZSxcclxuICBib29sZWFuQXR0cmlidXRlLFxyXG4gIHJ1bkluSW5qZWN0aW9uQ29udGV4dCxcclxuICBpbnB1dCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgT25Jbml0LFxyXG4gIEFmdGVyVmlld0luaXQsXHJcbiAgRWxlbWVudFJlZixcclxuICBOZ1pvbmUsXHJcbiAgU2lnbmFsLFxyXG4gIElucHV0U2lnbmFsLFxyXG4gIEluamVjdG9yLFxyXG4gIFdyaXRhYmxlU2lnbmFsLFxyXG4gIEVmZmVjdENsZWFudXBSZWdpc3RlckZuLFxyXG4gIElucHV0U2lnbmFsV2l0aFRyYW5zZm9ybVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XHJcbmltcG9ydCB7IERpcmVjdGlvbiwgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XHJcbmltcG9ydCB7IHRvU2lnbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIG1hcCwgdGFwIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7XHJcbiAgU21vb3RoU2Nyb2xsRWxlbWVudCxcclxuICBTbW9vdGhTY3JvbGxNYW5hZ2VyLFxyXG4gIFNtb290aFNjcm9sbFRvRWxlbWVudE9wdGlvbnMsXHJcbiAgU21vb3RoU2Nyb2xsVG9PcHRpb25zXHJcbn0gZnJvbSAnbmd4LXNjcm9sbGJhci9zbW9vdGgtc2Nyb2xsJztcclxuaW1wb3J0IHsgU2Nyb2xsYmFycyB9IGZyb20gJy4vc2Nyb2xsYmFycy9zY3JvbGxiYXJzJztcclxuaW1wb3J0IHsgX05nU2Nyb2xsYmFyLCBOR19TQ1JPTExCQVIgfSBmcm9tICcuL3V0aWxzL3Njcm9sbGJhci1iYXNlJztcclxuaW1wb3J0IHsgcmVzaXplT2JzZXJ2ZXIsIFZpZXdwb3J0QWRhcHRlciB9IGZyb20gJy4vdmlld3BvcnQnO1xyXG5pbXBvcnQgeyBTY3JvbGxiYXJEcmFnZ2luZywgVmlld3BvcnRCb3VuZGFyaWVzIH0gZnJvbSAnLi91dGlscy9jb21tb24nO1xyXG5pbXBvcnQge1xyXG4gIFNjcm9sbGJhckFwcGVhcmFuY2UsXHJcbiAgU2Nyb2xsYmFyUG9zaXRpb24sXHJcbiAgU2Nyb2xsYmFyT3JpZW50YXRpb24sXHJcbiAgU2Nyb2xsYmFyVXBkYXRlUmVhc29uLFxyXG4gIFNjcm9sbGJhclZpc2liaWxpdHksXHJcbiAgTmdTY3JvbGxiYXJPcHRpb25zLFxyXG4gIE5HX1NDUk9MTEJBUl9PUFRJT05TXHJcbn0gZnJvbSAnLi9uZy1zY3JvbGxiYXIubW9kZWwnO1xyXG5cclxuaW50ZXJmYWNlIFZpZXdwb3J0U3RhdGUge1xyXG4gIHZlcnRpY2FsVXNlZDogYm9vbGVhbixcclxuICBob3Jpem9udGFsVXNlZDogYm9vbGVhbixcclxuICBpc1ZlcnRpY2FsbHlTY3JvbGxhYmxlOiBib29sZWFuLFxyXG4gIGlzSG9yaXpvbnRhbGx5U2Nyb2xsYWJsZTogYm9vbGVhbixcclxufVxyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgaG9zdDoge1xyXG4gICAgJ1tjbGFzcy5uZy1zY3JvbGxiYXJdJzogJ3RydWUnLFxyXG4gICAgJ1thdHRyLnZlcnRpY2FsVXNlZF0nOiAndmVydGljYWxVc2VkKCknLFxyXG4gICAgJ1thdHRyLmhvcml6b250YWxVc2VkXSc6ICdob3Jpem9udGFsVXNlZCgpJyxcclxuICAgICdbYXR0ci5pc1ZlcnRpY2FsbHlTY3JvbGxhYmxlXSc6ICdpc1ZlcnRpY2FsbHlTY3JvbGxhYmxlKCknLFxyXG4gICAgJ1thdHRyLmlzSG9yaXpvbnRhbGx5U2Nyb2xsYWJsZV0nOiAnaXNIb3Jpem9udGFsbHlTY3JvbGxhYmxlKCknLFxyXG4gICAgJ1thdHRyLm1vYmlsZV0nOiAnaXNNb2JpbGUnLFxyXG4gICAgJ1thdHRyLmRpcl0nOiAnZGlyZWN0aW9uKCknLFxyXG4gICAgJ1thdHRyLnBvc2l0aW9uXSc6ICdwb3NpdGlvbicsXHJcbiAgICAnW2F0dHIuZHJhZ2dpbmddJzogJ2RyYWdnaW5nKCknLFxyXG4gICAgJ1thdHRyLmFwcGVhcmFuY2VdJzogJ2FwcGVhcmFuY2UnLFxyXG4gICAgJ1thdHRyLnZpc2liaWxpdHldJzogJ3Zpc2liaWxpdHkoKScsXHJcbiAgICAnW2F0dHIub3JpZW50YXRpb25dJzogJ29yaWVudGF0aW9uKCknLFxyXG4gICAgJ1thdHRyLmRpc2FibGVJbnRlcmFjdGlvbl0nOiAnZGlzYWJsZUludGVyYWN0aW9uKCknXHJcbiAgfSxcclxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5HX1NDUk9MTEJBUiwgdXNlRXhpc3Rpbmc6IE5nU2Nyb2xsYmFyQ29yZSB9XVxyXG59KVxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTmdTY3JvbGxiYXJDb3JlIGltcGxlbWVudHMgX05nU2Nyb2xsYmFyLCBPbkluaXQsIEFmdGVyVmlld0luaXQge1xyXG5cclxuICAvKiogR2xvYmFsIG9wdGlvbnMgKi9cclxuICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IE5nU2Nyb2xsYmFyT3B0aW9ucyA9IGluamVjdChOR19TQ1JPTExCQVJfT1BUSU9OUyk7XHJcblxyXG4gIHByaXZhdGUgcmVhZG9ubHkgem9uZTogTmdab25lID0gaW5qZWN0KE5nWm9uZSk7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBwbGF0Zm9ybTogUGxhdGZvcm0gPSBpbmplY3QoUGxhdGZvcm0pO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgaW5qZWN0b3I6IEluamVjdG9yID0gaW5qZWN0KEluamVjdG9yKTtcclxuXHJcbiAgLyoqIEEgZmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgcGxhdGZvcm0gaXMgbW9iaWxlICovXHJcbiAgcmVhZG9ubHkgaXNNb2JpbGU6IGJvb2xlYW4gPSB0aGlzLnBsYXRmb3JtLklPUyB8fCB0aGlzLnBsYXRmb3JtLkFORFJPSUQ7XHJcbiAgZGlyOiBEaXJlY3Rpb25hbGl0eSA9IGluamVjdChEaXJlY3Rpb25hbGl0eSk7XHJcblxyXG4gIHNtb290aFNjcm9sbDogU21vb3RoU2Nyb2xsTWFuYWdlciA9IGluamVjdChTbW9vdGhTY3JvbGxNYW5hZ2VyKTtcclxuXHJcbiAgbmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQgPSBpbmplY3QoRWxlbWVudFJlZjxIVE1MRWxlbWVudD4pLm5hdGl2ZUVsZW1lbnQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZGlyZWN0aW9uIGlzICdsdHInIG9yICdydGwnXHJcbiAgICovXHJcbiAgZGlyZWN0aW9uOiBTaWduYWw8RGlyZWN0aW9uPjtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5kaWNhdGVzIHdoZW4gc2Nyb2xsYmFyIHRodW1iIGlzIGJlaW5nIGRyYWdnZWRcclxuICAgKi9cclxuICBkcmFnZ2luZzogV3JpdGFibGVTaWduYWw8U2Nyb2xsYmFyRHJhZ2dpbmc+ID0gc2lnbmFsKCdub25lJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHN1cHBvcnRlZCBzY3JvbGwgdHJhY2sgb2YgdGhlIHZpZXdwb3J0LCB0aGVyZSBhcmUgMyBvcHRpb25zOlxyXG4gICAqXHJcbiAgICogLSBgdmVydGljYWxgIFVzZSBib3RoIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHNjcm9sbGJhclxyXG4gICAqIC0gYGhvcml6b250YWxgIFVzZSBib3RoIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHNjcm9sbGJhclxyXG4gICAqIC0gYGF1dG9gIFVzZSBib3RoIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHNjcm9sbGJhclxyXG4gICAqL1xyXG4gIG9yaWVudGF0aW9uOiBJbnB1dFNpZ25hbDxTY3JvbGxiYXJPcmllbnRhdGlvbj4gPSBpbnB1dDxTY3JvbGxiYXJPcmllbnRhdGlvbj4odGhpcy5vcHRpb25zLm9yaWVudGF0aW9uKTtcclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiB0byBzaG93IHRoZSBzY3JvbGxiYXIsIGFuZCB0aGVyZSBhcmUgMyBvcHRpb25zOlxyXG4gICAqXHJcbiAgICogLSBgbmF0aXZlYCAoZGVmYXVsdCkgU2Nyb2xsYmFyIHdpbGwgYmUgdmlzaWJsZSB3aGVuIHZpZXdwb3J0IGlzIHNjcm9sbGFibGUgbGlrZSB3aXRoIG5hdGl2ZSBzY3JvbGxiYXJcclxuICAgKiAtIGBob3ZlcmAgU2Nyb2xsYmFycyBhcmUgaGlkZGVuIGJ5IGRlZmF1bHQsIG9ubHkgdmlzaWJsZSBvbiBzY3JvbGxpbmcgb3IgaG92ZXJpbmdcclxuICAgKiAtIGBhbHdheXNgIFNjcm9sbGJhcnMgYXJlIGFsd2F5cyBzaG93biBldmVuIGlmIHRoZSB2aWV3cG9ydCBpcyBub3Qgc2Nyb2xsYWJsZVxyXG4gICAqL1xyXG4gIHZpc2liaWxpdHk6IElucHV0U2lnbmFsPFNjcm9sbGJhclZpc2liaWxpdHk+ID0gaW5wdXQ8U2Nyb2xsYmFyVmlzaWJpbGl0eT4odGhpcy5vcHRpb25zLnZpc2liaWxpdHkpO1xyXG5cclxuICAvKiogU2hvdyBzY3JvbGxiYXIgYnV0dG9ucyAqL1xyXG4gIGJ1dHRvbnM6IElucHV0U2lnbmFsV2l0aFRyYW5zZm9ybTxib29sZWFuLCBzdHJpbmcgfCBib29sZWFuPiA9IGlucHV0PGJvb2xlYW4sIHN0cmluZyB8IGJvb2xlYW4+KHRoaXMub3B0aW9ucy5idXR0b25zLCB7XHJcbiAgICB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGVcclxuICB9KTtcclxuXHJcbiAgLyoqIERpc2FibGVzIHNjcm9sbGJhciBpbnRlcmFjdGlvbiBsaWtlIGRyYWdnaW5nIHRodW1iIGFuZCBqdW1waW5nIGJ5IHRyYWNrIGNsaWNrICovXHJcbiAgZGlzYWJsZUludGVyYWN0aW9uOiBJbnB1dFNpZ25hbFdpdGhUcmFuc2Zvcm08Ym9vbGVhbiwgc3RyaW5nIHwgYm9vbGVhbj4gPSBpbnB1dDxib29sZWFuLCBzdHJpbmcgfCBib29sZWFuPih0aGlzLm9wdGlvbnMuZGlzYWJsZUludGVyYWN0aW9uLCB7XHJcbiAgICB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGVcclxuICB9KTtcclxuXHJcbiAgLyoqIFdoZXRoZXIgUmVzaXplT2JzZXJ2ZXIgaXMgZGlzYWJsZWQgKi9cclxuICBkaXNhYmxlU2Vuc29yOiBJbnB1dFNpZ25hbFdpdGhUcmFuc2Zvcm08Ym9vbGVhbiwgc3RyaW5nIHwgYm9vbGVhbj4gPSBpbnB1dDxib29sZWFuLCBzdHJpbmcgfCBib29sZWFuPih0aGlzLm9wdGlvbnMuZGlzYWJsZVNlbnNvciwge1xyXG4gICAgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlXHJcbiAgfSk7XHJcblxyXG4gIC8qKiBUaHJvdHRsZSBpbnRlcnZhbCBmb3IgZGV0ZWN0aW5nIGNoYW5nZXMgdmlhIFJlc2l6ZU9ic2VydmVyICovXHJcbiAgc2Vuc29yVGhyb3R0bGVUaW1lOiBJbnB1dFNpZ25hbDxudW1iZXI+ID0gaW5wdXQ8bnVtYmVyLCBudW1iZXI+KHRoaXMub3B0aW9ucy5zZW5zb3JUaHJvdHRsZVRpbWUsIHtcclxuICAgIHRyYW5zZm9ybTogbnVtYmVyQXR0cmlidXRlXHJcbiAgfSk7XHJcblxyXG4gIC8qKiBBIGZsYWcgdXNlZCB0byBhY3RpdmF0ZSBob3ZlciBlZmZlY3Qgb24gdGhlIG9mZnNldCBhcmVhIGFyb3VuZCB0aGUgc2Nyb2xsYmFyICovXHJcbiAgaG92ZXJPZmZzZXQ6IElucHV0U2lnbmFsV2l0aFRyYW5zZm9ybTxib29sZWFuLCBzdHJpbmcgfCBib29sZWFuPiA9IGlucHV0PGJvb2xlYW4sIHN0cmluZyB8IGJvb2xlYW4+KHRoaXMub3B0aW9ucy5ob3Zlck9mZnNldCwge1xyXG4gICAgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlXHJcbiAgfSk7XHJcblxyXG4gIHZpZXdwb3J0RGltZW5zaW9uOiBXcml0YWJsZVNpZ25hbDxWaWV3cG9ydEJvdW5kYXJpZXM+ID0gc2lnbmFsKHtcclxuICAgIGNvbnRlbnRIZWlnaHQ6IDAsXHJcbiAgICBjb250ZW50V2lkdGg6IDAsXHJcbiAgICBvZmZzZXRIZWlnaHQ6IDAsXHJcbiAgICBvZmZzZXRXaWR0aDogMFxyXG4gIH0pO1xyXG5cclxuICBzdGF0ZTogU2lnbmFsPFZpZXdwb3J0U3RhdGU+ID0gY29tcHV0ZWQoKCkgPT4ge1xyXG4gICAgbGV0IHZlcnRpY2FsVXNlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgbGV0IGhvcml6b250YWxVc2VkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBsZXQgaXNWZXJ0aWNhbGx5U2Nyb2xsYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgbGV0IGlzSG9yaXpvbnRhbGx5U2Nyb2xsYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0IG9yaWVudGF0aW9uOiBTY3JvbGxiYXJPcmllbnRhdGlvbiA9IHRoaXMub3JpZW50YXRpb24oKTtcclxuICAgIGNvbnN0IHZpc2liaWxpdHk6IFNjcm9sbGJhclZpc2liaWxpdHkgPSB0aGlzLnZpc2liaWxpdHkoKTtcclxuICAgIGNvbnN0IHZpZXdwb3J0OiBWaWV3cG9ydEJvdW5kYXJpZXMgPSB0aGlzLnZpZXdwb3J0RGltZW5zaW9uKCk7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdmVydGljYWwgc2Nyb2xsYmFyIHNob3VsZCBiZSBkaXNwbGF5ZWRcclxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2F1dG8nIHx8IG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgIGlzVmVydGljYWxseVNjcm9sbGFibGUgPSB2aWV3cG9ydC5jb250ZW50SGVpZ2h0ID4gdmlld3BvcnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICB2ZXJ0aWNhbFVzZWQgPSB2aXNpYmlsaXR5ID09PSAndmlzaWJsZScgfHwgaXNWZXJ0aWNhbGx5U2Nyb2xsYWJsZTtcclxuICAgIH1cclxuICAgIC8vIENoZWNrIGlmIGhvcml6b250YWwgc2Nyb2xsYmFyIHNob3VsZCBiZSBkaXNwbGF5ZWRcclxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2F1dG8nIHx8IG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgaXNIb3Jpem9udGFsbHlTY3JvbGxhYmxlID0gdmlld3BvcnQuY29udGVudFdpZHRoID4gdmlld3BvcnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgIGhvcml6b250YWxVc2VkID0gdmlzaWJpbGl0eSA9PT0gJ3Zpc2libGUnIHx8IGlzSG9yaXpvbnRhbGx5U2Nyb2xsYWJsZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB2ZXJ0aWNhbFVzZWQsXHJcbiAgICAgIGhvcml6b250YWxVc2VkLFxyXG4gICAgICBpc1ZlcnRpY2FsbHlTY3JvbGxhYmxlLFxyXG4gICAgICBpc0hvcml6b250YWxseVNjcm9sbGFibGUsXHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuICBpc1ZlcnRpY2FsbHlTY3JvbGxhYmxlOiBTaWduYWw8Ym9vbGVhbj4gPSBjb21wdXRlZCgoKSA9PiB0aGlzLnN0YXRlKCkuaXNWZXJ0aWNhbGx5U2Nyb2xsYWJsZSk7XHJcbiAgaXNIb3Jpem9udGFsbHlTY3JvbGxhYmxlOiBTaWduYWw8Ym9vbGVhbj4gPSBjb21wdXRlZCgoKSA9PiB0aGlzLnN0YXRlKCkuaXNIb3Jpem9udGFsbHlTY3JvbGxhYmxlKTtcclxuICB2ZXJ0aWNhbFVzZWQ6IFNpZ25hbDxib29sZWFuPiA9IGNvbXB1dGVkKCgpID0+IHRoaXMuc3RhdGUoKS52ZXJ0aWNhbFVzZWQpO1xyXG4gIGhvcml6b250YWxVc2VkOiBTaWduYWw8Ym9vbGVhbj4gPSBjb21wdXRlZCgoKSA9PiB0aGlzLnN0YXRlKCkuaG9yaXpvbnRhbFVzZWQpO1xyXG5cclxuICAvKiogU2Nyb2xsIGR1cmF0aW9uIHdoZW4gdGhlIHNjcm9sbCB0cmFjayBpcyBjbGlja2VkICovXHJcbiAgQElucHV0KHsgdHJhbnNmb3JtOiBudW1iZXJBdHRyaWJ1dGUgfSkgdHJhY2tTY3JvbGxEdXJhdGlvbjogbnVtYmVyID0gdGhpcy5vcHRpb25zLnRyYWNrU2Nyb2xsRHVyYXRpb247XHJcblxyXG4gIC8qKlxyXG4gICAqICBTZXRzIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBzY3JvbGxiYXIsIHRoZXJlIGFyZSAyIG9wdGlvbnM6XHJcbiAgICpcclxuICAgKiAtIGBuYXRpdmVgIChkZWZhdWx0KSBzY3JvbGxiYXIgc3BhY2Ugd2lsbCBiZSByZXNlcnZlZCBqdXN0IGxpa2Ugd2l0aCBuYXRpdmUgc2Nyb2xsYmFyLlxyXG4gICAqIC0gYGNvbXBhY3RgIHNjcm9sbGJhciBkb2Vzbid0IHJlc2VydmUgYW55IHNwYWNlLCB0aGV5IGFyZSBwbGFjZWQgb3ZlciB0aGUgdmlld3BvcnQuXHJcbiAgICovXHJcbiAgQElucHV0KCkgYXBwZWFyYW5jZTogU2Nyb2xsYmFyQXBwZWFyYW5jZSA9IHRoaXMub3B0aW9ucy5hcHBlYXJhbmNlO1xyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIGVhY2ggc2Nyb2xsYmFyLCB0aGVyZSBhcmUgNCBvcHRpb25zOlxyXG4gICAqXHJcbiAgICogLSBgbmF0aXZlYCAoRGVmYXVsdCkgVXNlIHRoZSBkZWZhdWx0IHBvc2l0aW9uIGxpa2UgaW4gbmF0aXZlIHNjcm9sbGJhci5cclxuICAgKiAtIGBpbnZlcnRZYCBJbnZlcnRzIHZlcnRpY2FsIHNjcm9sbGJhciBwb3NpdGlvblxyXG4gICAqIC0gYGludmVydFhgIEludmVydHMgSG9yaXpvbnRhbCBzY3JvbGxiYXIgcG9zaXRpb25cclxuICAgKiAtIGBpbnZlcnRBbGxgIEludmVydHMgYm90aCBzY3JvbGxiYXIgcG9zaXRpb25zXHJcbiAgICovXHJcbiAgQElucHV0KCkgcG9zaXRpb246IFNjcm9sbGJhclBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cclxuICAvKiogQSBjbGFzcyBmb3J3YXJkZWQgdG8gdGhlIHNjcm9sbGJhciB0cmFjayBlbGVtZW50ICovXHJcbiAgQElucHV0KCkgdHJhY2tDbGFzczogc3RyaW5nID0gdGhpcy5vcHRpb25zLnRyYWNrQ2xhc3M7XHJcbiAgLyoqIEEgY2xhc3MgZm9yd2FyZGVkIHRvIHRoZSBzY3JvbGxiYXIgdGh1bWIgZWxlbWVudCAqL1xyXG4gIEBJbnB1dCgpIHRodW1iQ2xhc3M6IHN0cmluZyA9IHRoaXMub3B0aW9ucy50aHVtYkNsYXNzO1xyXG4gIC8qKiBBIGNsYXNzIGZvcndhcmRlZCB0byB0aGUgc2Nyb2xsYmFyIGJ1dHRvbiBlbGVtZW50ICovXHJcbiAgQElucHV0KCkgYnV0dG9uQ2xhc3M6IHN0cmluZyA9IHRoaXMub3B0aW9ucy50aHVtYkNsYXNzO1xyXG5cclxuICAvKiogU3RlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbGJhciBpcyBpbml0aWFsaXplZCAqL1xyXG4gIEBPdXRwdXQoKSBhZnRlckluaXQ6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcclxuXHJcbiAgLyoqIFN0ZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGxiYXIgaXMgdXBkYXRlZCAqL1xyXG4gIEBPdXRwdXQoKSBhZnRlclVwZGF0ZTogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuICAvKiogUmVzaXplIG9ic2VydmVyIHN1YnNjcmlwdGlvbiAqL1xyXG4gIHByaXZhdGUgc2l6ZUNoYW5nZVN1YjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAvKiogVmlld3BvcnQgYWRhcHRlciBpbnN0YW5jZSAqL1xyXG4gIHZpZXdwb3J0OiBWaWV3cG9ydEFkYXB0ZXIgPSBuZXcgVmlld3BvcnRBZGFwdGVyKCk7XHJcblxyXG4gIC8qKiBUaGUgc2Nyb2xsYmFycyBjb21wb25lbnQgaW5zdGFuY2UgdXNlZCBmb3IgdGVzdGluZyBwdXJwb3NlICovXHJcbiAgYWJzdHJhY3QgX3Njcm9sbGJhcnM6IFNjcm9sbGJhcnM7XHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgcnVuSW5JbmplY3Rpb25Db250ZXh0KHRoaXMuaW5qZWN0b3IsICgpID0+IHtcclxuICAgICAgLy8gVGhlIGRpcmVjdGlvbiBzaWduYWwgY2Fubm90IGJlIGluaXRpYWxpemVkIGluIHRoZSBjb25zdHJ1Y3RvclxyXG4gICAgICAvLyBCZWNhdXNlIGl0IGluaXRpYWxseSByZXR1cm5zICdsdHInIGV2ZW4gaWYgZGlyLnZhbHVlIGlzICdydGxgLCB0aGUgbWFwIGZ1bmN0aW9uIGhlcmUgaXMgY3J1Y2lhbFxyXG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IHRvU2lnbmFsPERpcmVjdGlvbiwgRGlyZWN0aW9uPih0aGlzLmRpci5jaGFuZ2UucGlwZShtYXAoKCkgPT4gdGhpcy5kaXIudmFsdWUpKSwgeyBpbml0aWFsVmFsdWU6IHRoaXMuZGlyLnZhbHVlIH0pO1xyXG5cclxuICAgICAgZWZmZWN0KChvbkNsZWFudXA6IEVmZmVjdENsZWFudXBSZWdpc3RlckZuKSA9PiB7XHJcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBzZW5zb3Igc2hvdWxkIGJlIGVuYWJsZWRcclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlU2Vuc29yKCkpIHtcclxuICAgICAgICAgIC8vIElmIHNlbnNvciBpcyBkaXNhYmxlZCB1cGRhdGUgbWFudWFsbHlcclxuICAgICAgICAgIHRoaXMuc2l6ZUNoYW5nZVN1Yj8udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0uaXNCcm93c2VyICYmIHRoaXMudmlld3BvcnQuaW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNpemVDaGFuZ2VTdWI/LnVuc3Vic2NyaWJlKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMuc2l6ZUNoYW5nZVN1YiA9IHJlc2l6ZU9ic2VydmVyKHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMudmlld3BvcnQubmF0aXZlRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRXcmFwcGVyOiB0aGlzLnZpZXdwb3J0LmNvbnRlbnRXcmFwcGVyRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHRocm90dGxlRHVyYXRpb246IHRoaXMuc2Vuc29yVGhyb3R0bGVUaW1lKClcclxuICAgICAgICAgICAgICB9KS5waXBlKFxyXG4gICAgICAgICAgICAgICAgdGFwKChyZWFzb246IFNjcm9sbGJhclVwZGF0ZVJlYXNvbikgPT4gdGhpcy51cGRhdGUocmVhc29uKSlcclxuICAgICAgICAgICAgICApLnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9uQ2xlYW51cCgoKSA9PiB0aGlzLnNpemVDaGFuZ2VTdWI/LnVuc3Vic2NyaWJlKCkpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgLy8gSWYgc2Vuc29yIGlzIGRpc2FibGVkLCB1cGRhdGUgdG8gZXZhbHVhdGUgdGhlIHN0YXRlXHJcbiAgICBpZiAodGhpcy5wbGF0Zm9ybS5pc0Jyb3dzZXIgJiYgdGhpcy5kaXNhYmxlU2Vuc29yKCkpIHtcclxuICAgICAgLy8gSW4gY2FzZSBvZiAzcmQgcGFydHkgbGlicmFyeSwgbmVlZCB0byB3YWl0IGZvciBjb250ZW50IHRvIGJlIHJlbmRlcmVkXHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoU2Nyb2xsYmFyVXBkYXRlUmVhc29uLkFmdGVySW5pdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGxvY2FsIHN0YXRlIGFuZCB0aGUgaW50ZXJuYWwgc2Nyb2xsYmFyIGNvbnRyb2xzXHJcbiAgICovXHJcbiAgdXBkYXRlKHJlYXNvbj86IFNjcm9sbGJhclVwZGF0ZVJlYXNvbik6IHZvaWQge1xyXG4gICAgdGhpcy51cGRhdGVDU1NWYXJpYWJsZXMoKTtcclxuXHJcbiAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgdGhpcy52aWV3cG9ydERpbWVuc2lvbi5zZXQoe1xyXG4gICAgICAgIGNvbnRlbnRIZWlnaHQ6IHRoaXMudmlld3BvcnQuY29udGVudEhlaWdodCxcclxuICAgICAgICBjb250ZW50V2lkdGg6IHRoaXMudmlld3BvcnQuY29udGVudFdpZHRoLFxyXG4gICAgICAgIG9mZnNldEhlaWdodDogdGhpcy52aWV3cG9ydC5vZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgb2Zmc2V0V2lkdGg6IHRoaXMudmlld3BvcnQub2Zmc2V0V2lkdGhcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBBZnRlciB0aGUgdXBncmFkZSB0byBBbmd1bGFyIDE4LCB0aGUgZWZmZWN0IGZ1bmN0aW9ucyBpbiB0aGUgaW5uZXIgZGlyZWN0aXZlcyBhcmUgZXhlY3V0ZWQgYWZ0ZXIgXCJhZnRlckluaXRcIiBpcyBlbWl0dGVkLFxyXG4gICAgICAvLyBjYXVzaW5nIHRoZSB0ZXN0cyB0byBmYWlsLiBBIHRpbnkgZGVsYXkgaXMgbmVlZGVkIGJlZm9yZSBlbWl0dGluZyB0byB0aGUgb3V0cHV0IGFzIGEgd29ya2Fyb3VuZC5cclxuICAgICAgaWYgKHJlYXNvbiA9PT0gU2Nyb2xsYmFyVXBkYXRlUmVhc29uLkFmdGVySW5pdCkge1xyXG4gICAgICAgIHRoaXMuYWZ0ZXJJbml0LmVtaXQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFmdGVyVXBkYXRlLmVtaXQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTbW9vdGggc2Nyb2xsIGZ1bmN0aW9uc1xyXG4gICAqL1xyXG4gIHNjcm9sbFRvKG9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc21vb3RoU2Nyb2xsLnNjcm9sbFRvKHRoaXMudmlld3BvcnQubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgdG8gZWxlbWVudCBieSByZWZlcmVuY2Ugb3Igc2VsZWN0b3JcclxuICAgKi9cclxuICBzY3JvbGxUb0VsZW1lbnQodGFyZ2V0OiBTbW9vdGhTY3JvbGxFbGVtZW50LCBvcHRpb25zPzogU21vb3RoU2Nyb2xsVG9FbGVtZW50T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc21vb3RoU2Nyb2xsLnNjcm9sbFRvRWxlbWVudCh0aGlzLnZpZXdwb3J0Lm5hdGl2ZUVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgRXNzZW50aWFsIENTUyB2YXJpYWJsZXNcclxuICAgKi9cclxuICBwcml2YXRlIHVwZGF0ZUNTU1ZhcmlhYmxlcygpOiB2b2lkIHtcclxuICAgIHRoaXMubmF0aXZlRWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1jb250ZW50LWhlaWdodCcsIGAkeyB0aGlzLnZpZXdwb3J0LmNvbnRlbnRIZWlnaHQgfWApO1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLWNvbnRlbnQtd2lkdGgnLCBgJHsgdGhpcy52aWV3cG9ydC5jb250ZW50V2lkdGggfWApO1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLXZpZXdwb3J0LWhlaWdodCcsIGAkeyB0aGlzLnZpZXdwb3J0Lm9mZnNldEhlaWdodCB9YCk7XHJcbiAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tdmlld3BvcnQtd2lkdGgnLCBgJHsgdGhpcy52aWV3cG9ydC5vZmZzZXRXaWR0aCB9YCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==