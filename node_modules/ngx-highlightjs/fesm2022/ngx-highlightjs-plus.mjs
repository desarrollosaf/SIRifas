import * as i0 from '@angular/core';
import { InjectionToken, inject, Injectable, EventEmitter, Directive, Input, Output, Pipe, NgModule } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { shareReplay, catchError, EMPTY } from 'rxjs';
import { DOCUMENT } from '@angular/common';

function isUrl(url) {
    const regExp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!]))?/;
    return regExp.test(url);
}
const GIST_OPTIONS = new InjectionToken('GIST_OPTIONS');
function provideGistOptions(options) {
    return [
        {
            provide: GIST_OPTIONS,
            useValue: options
        }
    ];
}

class CodeLoader {
    constructor() {
        this._http = inject(HttpClient);
        this._options = inject(GIST_OPTIONS, { optional: true });
    }
    /**
     * Get plus code
     * @param id Gist ID
     */
    getCodeFromGist(id) {
        let params;
        if (this._options?.clientId && this._options?.clientSecret) {
            params = new HttpParams().set('client_id', this._options.clientId).set('client_secret', this._options.clientSecret);
        }
        return this.fetchFile(`https://api.github.com/gists/${id}`, { params, responseType: 'json' });
    }
    /**
     * Get code by URL
     * @param url File raw link
     */
    getCodeFromUrl(url) {
        return this.fetchFile(url, { responseType: 'text' });
    }
    fetchFile(url, options) {
        // Check if URL is valid
        if (isUrl(url)) {
            return this._http.get(url, options).pipe(
            // Catch response
            shareReplay(1), catchError((err) => {
                console.error('[NgxHighlight]: Unable to fetch the URL!', err.message);
                return EMPTY;
            }));
        }
        return EMPTY;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: CodeLoader, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: CodeLoader, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: CodeLoader, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class GistDirective {
    constructor() {
        this._loader = inject(CodeLoader);
        this.gistLoad = new EventEmitter();
    }
    set gist(value) {
        if (value) {
            this._loader.getCodeFromGist(value).subscribe((gist) => this.gistLoad.emit(gist));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: GistDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: GistDirective, isStandalone: true, selector: "[gist]", inputs: { gist: "gist" }, outputs: { gistLoad: "gistLoad" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: GistDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[gist]'
                }]
        }], propDecorators: { gist: [{
                type: Input
            }], gistLoad: [{
                type: Output
            }] } });
class GistFilePipe {
    transform(gist, fileName) {
        return (gist && gist.files && gist.files[fileName]) ? gist.files[fileName].content : null;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: GistFilePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: GistFilePipe, isStandalone: true, name: "gistFile" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: GistFilePipe, decorators: [{
            type: Pipe,
            args: [{
                    standalone: true,
                    name: 'gistFile'
                }]
        }] });

/**
 * Injection token used to provide the current location to `codeFromUrl` pipe.
 * Used to handle server-side rendering and to stub out during unit tests.
 */
const HIGHLIGHT_FILE_LOCATION = new InjectionToken('HIGHLIGHT_FILE_LOCATION', {
    providedIn: 'root',
    factory: CODE_FILE_LOCATION_FACTORY,
});
function CODE_FILE_LOCATION_FACTORY() {
    const _location = inject(DOCUMENT)?.location;
    return {
        // Note that this needs to be a function, rather than a property, because Angular
        // will only resolve it once, but we want the current path on each call.
        // getPathname: () => (_location ? _location.pathname + _location.search : ''),
        getPathname: () => (_location ? _location.origin : '')
    };
}

class CodeFromUrlPipe {
    constructor() {
        this._location = inject(HIGHLIGHT_FILE_LOCATION);
        this._loader = inject(CodeLoader);
    }
    transform(url) {
        return this._loader.getCodeFromUrl(isUrl(url) ? url : `${this._location.getPathname()}/${url}`);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: CodeFromUrlPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: CodeFromUrlPipe, isStandalone: true, name: "codeFromUrl" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: CodeFromUrlPipe, decorators: [{
            type: Pipe,
            args: [{
                    standalone: true,
                    name: 'codeFromUrl'
                }]
        }] });

class HighlightPlusModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: HighlightPlusModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: HighlightPlusModule, imports: [GistDirective,
            GistFilePipe,
            CodeFromUrlPipe], exports: [GistDirective,
            GistFilePipe,
            CodeFromUrlPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: HighlightPlusModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: HighlightPlusModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        GistDirective,
                        GistFilePipe,
                        CodeFromUrlPipe
                    ],
                    exports: [
                        GistDirective,
                        GistFilePipe,
                        CodeFromUrlPipe
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { CodeFromUrlPipe, CodeLoader, GIST_OPTIONS, GistDirective, GistFilePipe, HighlightPlusModule, isUrl, provideGistOptions };
//# sourceMappingURL=ngx-highlightjs-plus.mjs.map
